As well as DriverUnload, there is the **MajorFunction** member of the DRIVER_OBJECT.  This is an array of pointers that specifies operations that the driver supports.  Without these, a caller cannot interact with the driver.  Each MajorFunction is referenced with an **IRP_MJan_** prefix, where IRP is short for **I/O Request Packet**.  Common functions include:

- IRP_MJ_CREATE
- IRP_MJ_CLOSE
- IRP_MJ_READ
- IRP_MJ_WRITE
- IRP_MJ_DEVICE_CONTROL



A driver should support at least **IRP_MJ_CREATE** and **IRP_MJ_CLOSE**, as these allow a calling client to open (and subsequently close) a handle to the driver itself.  The prototype for a dispatch routine is:

```
NTSTATUS SomeMethod(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp);
```



For now, let's register a function for these two and simply return a "success" status from them.

```
void DriverCleanup(PDRIVER_OBJECT DriverObject);
NTSTATUS CreateClose(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp);

extern "C"
NTSTATUS
DriverEntry(
	_In_ PDRIVER_OBJECT DriverObject,
	_In_ PUNICODE_STRING RegistryPath)
{
	UNREFERENCED_PARAMETER(RegistryPath);

	DbgPrint("[+] Hello from FirstDriver DriverEntry\n");

	DriverObject->DriverUnload = DriverCleanup;
	DriverObject->MajorFunction[IRP_MJ_CREATE] = CreateClose;
	DriverObject->MajorFunction[IRP_MJ_CLOSE] = CreateClose;

	return STATUS_SUCCESS;
}

NTSTATUS
CreateClose(
	_In_ PDEVICE_OBJECT DeviceObject,
	_In_ PIRP Irp)
{
	UNREFERENCED_PARAMETER(DeviceObject);

	DbgPrint("[+] Hello from FirstDriver CreateClose\n");

	Irp->IoStatus.Status = STATUS_SUCCESS;
	Irp->IoStatus.Information = 0;

	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	return STATUS_SUCCESS;
}
```



We can of course point both MajorFunctions to the same routine because we want them to be handled the same way.  To test this, create a userland application capable of opening and closing a handle to the driver.  To facilitate that, the driver first needs an associated device object and symlink.

```
UNICODE_STRING deviceName = RTL_CONSTANT_STRING(L"\\Device\\FirstDriver");
UNICODE_STRING symlink = RTL_CONSTANT_STRING(L"\\??\\FirstDriver");

extern "C"
NTSTATUS
DriverEntry(
	_In_ PDRIVER_OBJECT DriverObject,
	_In_ PUNICODE_STRING RegistryPath)
{
	UNREFERENCED_PARAMETER(RegistryPath);

	DbgPrint("[+] Hello from FirstDriver DriverEntry\n");

	DriverObject->DriverUnload = DriverCleanup;
	DriverObject->MajorFunction[IRP_MJ_CREATE] = CreateClose;
	DriverObject->MajorFunction[IRP_MJ_CLOSE] = CreateClose;
	
	PDEVICE_OBJECT deviceObject;
	NTSTATUS status = IoCreateDevice(
		DriverObject,
		0,
		&deviceName,
		FILE_DEVICE_UNKNOWN,
		0,
		FALSE,
		&deviceObject
	);

	if (!NT_SUCCESS(status))
	{
		DbgPrint("[!] Failed to create Device Object (0x%08X)\n", status);
		return status;
	}
	
	status = IoCreateSymbolicLink(&symlink, &deviceName);

	if (!NT_SUCCESS(status))
	{
		DbgPrint("[!] Failed to create symlink (0x%08X)\n", status);
		IoDeleteDevice(deviceObject);
		return status;
	}

	return STATUS_SUCCESS;
}

void
DriverCleanup(
	PDRIVER_OBJECT DriverObject)
{
	DbgPrint("[+] Hello from FirstDriver DriverUnload\n");

	IoDeleteSymbolicLink(&symlink);
	IoDeleteDevice(DriverObject->DeviceObject);
}
```



It's worth noting that if we don't return a success status from DriverEntry, then DriverUnload is not called afterwards.  For that reason, we have to ensure we free any allocations that we've made inside DriverEntry up to the point of failure.  And of course, we still have to free them from the DriverUnload for cases where the driver did load successfully.