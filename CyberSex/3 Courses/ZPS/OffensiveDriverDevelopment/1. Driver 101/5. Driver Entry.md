To create your first driver, open VS 2019 and create a new project.  From the project template selection, find the **Kernel Mode Driver, Empty (KMDF)**.

> **Note**:  There is a skeleton KMDF project template that provides more boilerplate code to get you started. But we want to start from scratch to ensure we understand the basic anatomy of a driver.



First, make sure the **x64** build is selected from the top menu.  Then create a new file under **Source Files** called `FirstDriver.cpp`.  The first thing a driver requires is a **DriverEntry** - think of this as the "main" function in userland executables.

The prototype for this method is:

```
NTSTATUS DriverEntry(
_In_ PDRIVER_OBJECT DriverObject,
_In_ PUNICODE_STRING RegistryPath)
```



We need to return a status code, so let's just return `STATUS_SUCCESS` for now.

```
#include <ntddk.h>

NTSTATUS
DriverEntry(
	_In_ PDRIVER_OBJECT DriverObject,
	_In_ PUNICODE_STRING RegistryPath)
{
	return STATUS_SUCCESS;
}
```



If you try to build this now, it will fail with two warnings regarding unreferenced parameters.  The project is configured with "treat warnings as errors" and therefore refuses to compile.  It's **very** important when creating drivers **not** to disable this setting, and to deal with the warnings as they come up.  If we ignore errors, we run the real risk of them causing issues such as memory leaks.

To get around this, we can use the `UNREFERENCED_PARAMETER` macro.

```
UNREFERENCED_PARAMETER(DriverObject);
UNREFERENCED_PARAMETER(RegistryPath);
```



The final step before the driver will build, is to add `extern "C"` before NTSTATUS.  This is to provide C-linkage, which is not the default for C++ compilation.  Your code should now look something like this:

```
#include <ntddk.h>

extern "C"
NTSTATUS
DriverEntry(
	_In_ PDRIVER_OBJECT DriverObject,
	_In_ PUNICODE_STRING RegistryPath)
{
	UNREFERENCED_PARAMETER(DriverObject);
	UNREFERENCED_PARAMETER(RegistryPath);

	return STATUS_SUCCESS;
}
```