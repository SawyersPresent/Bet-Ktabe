To send data to the driver, we can provide a buffer to `DeviceIoControl`.  Here's a basic example.  Create `Common.h` in the FirstDriver project and create a new struct.

```
struct TheQuestion
{
	int FirstNumber;
	int SecondNumber;
};
```



In the switch case for `FIRST_DRIVER_IOCTL_TEST`, the first task is to check that the buffer size is large enough to accommodate the expected data.

```
if (stack->Parameters.DeviceIoControl.InputBufferLength < sizeof(TheQuestion))
{
	status = STATUS_BUFFER_TOO_SMALL;
	DbgPrint("[+] STATUS_BUFFER_TOO_SMALL\n");
	break;
}
```



We can cast the data to a new pointer of `SomeData,` but we still need to check that it's not null.  Otherwise, the machine will BSOD if we try and access a member that doesn't exist.

```
TheQuestion* question = (TheQuestion*)stack->Parameters.DeviceIoControl.Type3InputBuffer;

if (data == nullptr)
{
	status = STATUS_INVALID_PARAMETER;
	DbgPrint("[+] STATUS_INVALID_PARAMETER\n");
	break;
}
```



Then we can do something with the data.

```
int first = question->FirstNumber;
int second = question->SecondNumber;
int result = first * second;

DbgPrint("[+] %d * %d = %d\n", first, second, result);

break;
```



We may still want to validate the data in some way.  For example, if we were dividing, we would certainly want to check for a potential divide by zero error, as that would also cause a BSOD.

To send that data from the client:

```
// call FIRST_DRIVER_IOCTL_TEST
TheQuestion question;
question.FirstNumber = 6;
question.SecondNumber = 7;

printf("[+] Calling FIRST_DRIVER_IOCTL_TEST...");
BOOL success = DeviceIoControl(
    hDriver,
    FIRST_DRIVER_IOCTL_TEST,
    &question,          // pointer to the data
    sizeof(question),   // the size of the data
    nullptr,
    0,
    nullptr,
    nullptr);
[+] Hello from FirstDriver DriverEntry
[+] Hello from FirstDriver CreateClose
[+] FIRST_DRIVER_IOCTL_TEST called
[+] 6 * 7 = 42
[+] Hello from FirstDriver CreateClose
```