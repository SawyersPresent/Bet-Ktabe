Instead of just sending the data to DbgPrint, let's return it to the caller.  Create a second struct to hold the response to be sent from the driver.

```
struct TheAnswer
{
	int Answer;
};
```



The driver should carry out the same checks on the output buffer before writing to it.

```
if (stack->Parameters.DeviceIoControl.OutputBufferLength < sizeof(TheAnswer))
{
	status = STATUS_BUFFER_TOO_SMALL;
	DbgPrint("[!] STATUS_BUFFER_TOO_SMALL\n");
	break;
}

TheAnswer* userBuffer = (TheAnswer*)Irp->UserBuffer;

if (userBuffer == nullptr)
{
	status = STATUS_INVALID_PARAMETER;
	DbgPrint("[!] STATUS_INVALID_PARAMETER\n");
	break;
}

userBuffer->Answer = answer;
length = sizeof(answer);

break;
```



The client should also create that output buffer and provide a pointer to DeviceIoControl.  If the call is successful, we can access and print the data.

```
printf("[+] Calling FIRST_DRIVER_IOCTL_TEST...");

TheAnswer answer;
DWORD bytesReturned;

BOOL success = DeviceIoControl(
    hDriver,
    FIRST_DRIVER_IOCTL_TEST,
    &data,              // pointer to the "question"
    sizeof(data),       // the size of the "question"
    &answer,            // pointer to "answer"
    sizeof(answer),     // size of "answer"
    &bytesReturned,
    nullptr);

if (success)
{
    printf("success!\n");
    printf("[+] Bytes returned: %d\n", bytesReturned);
    printf("[+] Result: %d\n", answer.Answer);

}
else
{
    printf("failed!\n");
}
```



```
C:\FirstDriver>FirstDriverClient.exe
[+] Opening handle to driver...success!
[+] Calling FIRST_DRIVER_IOCTL_TEST...success!
[+] Bytes returned: 4
[+] Result: 42
[+] Closing handle
```