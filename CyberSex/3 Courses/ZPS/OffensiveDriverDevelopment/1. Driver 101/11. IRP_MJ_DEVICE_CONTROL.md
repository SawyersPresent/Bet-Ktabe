Now that we have a driver and a client that can connect to it, the next step is to expose some functionality that the client can call.  For that, we can use the **IRP_MJ_DEVICE_CONTROL** MajorFunction.

```
NTSTATUS DeviceControl(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp);
//
DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DeviceControl;
```



Because we can define multiple functions, we need a way for the client to specify which one it wants.  We do that with **Device Input and Output Controls** (IOCTLs).  Create a new file called `ioctl.h` under **Header Files** of the driver project and add the following:

```
#define FIRST_DRIVER_DEVICE	0x8000

#define FIRST_DRIVER_IOCTL_TEST		CTL_CODE(FIRST_DRIVER_DEVICE, 0x800, METHOD_NEITHER, FILE_ANY_ACCESS)
```



Control codes need to be built with the CTL_CODE macro.  Here's a quick overview:

- The first parameter is a **DeviceType** - you can technically provide any value, but the Microsoft documentation states that 3rd party drivers start from **0x8000**.
- The second parameter is a **Function** value - as with DeviceType's, Microsoft says that 3rd party codes should start from **0x800**.  Each IOCTL in a driver must have a unique function value, so most often they're just incremented (0x800, 0x801 etc). 
- The next parameter defines how input and output buffers are passed to the driver.  **METHOD_NEITHER** tells the I/O manager not to provide any system buffers, meaning the IRP supplies the user-mode virtual address of the I/O buffers directly to the driver.  In this case, the input buffer can be found at **Parameters.DeviceIoControl.Type3InputBuffer** of the **PIO_STACK_LOCATION**; and the output buffer at **Irp->UserBuffer**.  There are risks associated with this, such as cases where the caller frees their buffer before the driver tries to write to it.
- The final parameter indicates whether this operation is to the driver, from the driver, or both ways.



Add the header to `FirstDriver.cpp` using `#include "ioctl.h"`. In the DeviceControl function, we need to extract the IOCTL the client has called.  For now, we'll just print a debug message.

```
NTSTATUS
DeviceControl(
	_In_ PDEVICE_OBJECT DeviceObject,
	_In_ PIRP Irp)
{
	UNREFERENCED_PARAMETER(DeviceObject);

	PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp);
	NTSTATUS status = STATUS_SUCCESS;
	ULONG_PTR length = 0;

	switch (stack->Parameters.DeviceIoControl.IoControlCode)
	{
	case FIRST_DRIVER_IOCTL_TEST:
		DbgPrint("[+] FIRST_DRIVER_IOCTL_TEST called\n");
		break;

	default:
		status = STATUS_INVALID_DEVICE_REQUEST;
		DbgPrint("[!] STATUS_INVALID_DEVICE_REQUEST\n");
		break;
	}

	Irp->IoStatus.Status = status;
	Irp->IoStatus.Information = length;

	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	return status;
}
```



Next - update the client.  First, add the same IOCTL header file with `#include "..\FirstDriver\ioctl.h"` (the path may vary depending on your VS solution structure).

To call IRP_MJ_DEVICE_CONTROL, we use the `DeviceIoControl` API.

```
    // open and validate handle...

    // call FIRST_DRIVER_IOCTL_TEST, should succeed
    printf("[+] Calling FIRST_DRIVER_IOCTL_TEST...");
    BOOL success = DeviceIoControl(
        hDriver,
        FIRST_DRIVER_IOCTL_TEST,
        nullptr,
        0,
        nullptr,
        0,
        nullptr,
        nullptr);

    if (success) { printf("success!\n"); }
    else { printf("failed!\n"); }

    // little sleep
    printf("Sleeping...\n");
    Sleep(3000);

    // call invalid control code, should fail
    printf("[+] Calling invalid IOCTL...");
    success = DeviceIoControl(
        hDriver,
        0x801,
        nullptr,
        0,
        nullptr,
        0,
        nullptr,
        nullptr);

    if (success) { printf("success!\n"); }
    else { printf("failed!\n"); }
```



The output from the console should look like this:

```
C:\FirstDriver>FirstDriverClient.exe
[+] Opening handle to driver...success!
[+] Calling FIRST_DRIVER_IOCTL_TEST...success!
[+] Sleeping...
[+] Calling invalid IOCTL...failed!
[+] Closing handle
```



And the output from WinDbg is like this:

```
[+] Hello from FirstDriver CreateClose
[+] FIRST_DRIVER_IOCTL_TEST called
[!] STATUS_INVALID_DEVICE_REQUEST
[+] Hello from FirstDriver CreateClose
```