Let's backtrack and think about how we're going to get the desired information to the client.  We only need to send the module name and the callback pointer.  Create a simple struct to accommodate that.

```
typedef struct _CALLBACK_INFORMATION
{
    CHAR   ModuleName[256];
    ULONG64 Pointer;
} CALLBACK_INFORMATION, * PCALLBACK_INFORMATION;
```



I took 256 from the fact that **AUX_KLIB_MODULE_PATH_LEN** in `aux_klib.h` is also 256.

The client should create a buffer large enough to hold 64 records and call the IOCTL.

```
CALLBACK_INFORMATION callbacks[64];
RtlZeroMemory(callbacks, sizeof(callbacks));

printf("[+] Calling RED_OCTOBER_ENUM_PROCESS_CALLBACKS...");

DWORD bytesReturned;
BOOL success = DeviceIoControl(
    hDriver,
    RED_OCTOBER_ENUM_PROCESS_CALLBACKS,
    nullptr,
    0,
    &callbacks,
    sizeof(callbacks),
    &bytesReturned,
    nullptr);
```



Within the case for **RED_OCTOBER_ENUM_PROCESS_CALLBACKS**, check the buffer being received is large enough and that we can recover a pointer to it.

```
case RED_OCTOBER_ENUM_PROCESS_CALLBACKS:
{
	ULONG szBuffer = sizeof(CALLBACK_INFORMATION) * 64;

	if (stack->Parameters.DeviceIoControl.OutputBufferLength < szBuffer)
	{
		status = STATUS_BUFFER_TOO_SMALL;
		KdPrint(("[!] STATUS_BUFFER_TOO_SMALL\n"));
		break;
	}

	CALLBACK_INFORMATION* userBuffer = (CALLBACK_INFORMATION*)Irp->UserBuffer;

	if (userBuffer == nullptr)
	{
		status = STATUS_INVALID_PARAMETER;
		KdPrint(("[!] STATUS_INVALID_PARAMETER\n"));
		break;
	}

    ...
}
```



Call the method for getting the address of the PspSetCreateProcessNotify array.

```
ULONG64 pspSetCreateProcessNotify = FindPspSetCreateProcessNotify(windowsVersion);

if (pspSetCreateProcessNotify == 0)
{
	status = STATUS_NOT_FOUND;
	break;
}
```



We'll then loop 64 times (for each possible callback) and attempt to find the module it exists in.

```
for (ULONG i = 0; i < 64; i++)
{
	// increment array pointer
	// 64 bit addresses are 8 bytes
	ULONG64 pCallback = pspSetCreateProcessNotify + (i * 8);
	ULONG64 callback = *(PULONG64)(pCallback);

	// set the Pointer member with the callback address
	userBuffer[i].Pointer = callback;

	// only search for module if there's an address
	if (callback > 0)
	{
		SearchLoadedModules(&userBuffer[i]);
	}

	// increase the amount of data we're telling the client we've returned
	length += sizeof(CALLBACK_INFORMATION);
}
```



I'm passing the instance of CALLBACK_INFORMATION into the SearchLoadedModules method and copying the module name if the correct module is identified.

```
ULONG64 rawPointer = *(PULONG64)(ModuleInfo->Pointer & 0xfffffffffffffff8);

if (rawPointer > startAddress && rawPointer < endAddress)
{
	strcpy(ModuleInfo->ModuleName, (CHAR*)(modules[i].FullPathName + modules[i].FileNameOffset));
	break;
}
```



Back on the client-side, we just check if the call to DeviceIoControl was successful and if so, print the information the driver has written into our buffer.

```
if (success)
{
    printf("success!\n\n");
    
    LONG numberOfCallbacks = bytesReturned / sizeof(CALLBACK_INFORMATION);

    for (LONG i = 0; i < numberOfCallbacks; i++)
    {
        // only display when there's an address
        if (callbacks[i].Pointer > 0)
        {
            printf("[%d] 0x%llX (%s)\n", i, callbacks[i].Pointer, callbacks[i].ModuleName);
        }
    }
}
C:\RedOctober>Client.exe
[+] Opening handle to driver...success!
[+] Calling RED_OCTOBER_ENUM_PROCESS_CALLBACKS...success!

[0] 0xFFFF8A897285266F (ntoskrnl.exe)
[1] 0xFFFF8A89729D7C6F (cng.sys)
[2] 0xFFFF8A8972EFFDEF (WdFilter.sys)
[3] 0xFFFF8A8972EFFE4F (ksecdd.sys)
[4] 0xFFFF8A89740F715F (tcpip.sys)
[5] 0xFFFF8A897414D73F (iorate.sys)
[6] 0xFFFF8A897414D88F (CI.dll)
[7] 0xFFFF8A897414DC1F (dxgkrnl.sys)
[8] 0xFFFF8A89785FC7AF (peauth.sys)
[9] 0xFFFF8A89790A1E1F (NotSysmon.sys)
```