Now that we can reliably find the location of the ProcessNotifyCallback array, we want to enumerate some information about the registered callbacks, such as which driver they belong to.  As you might expect, there's no easy way to achieve this either.  The [AuxKlibQueryModuleInformation](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/aux_klib/nf-aux_klib-auxklibquerymoduleinformation) API can be used to get the base address, image size and name of each loaded module.  Based on that, we can figure out which module a particular callback function exists in by looking to see if the address exists within the address range of a module.

The documentation for the Aux Library can be found [here](https://docs.microsoft.com/en-us/windows/win32/devnotes/aux-library).  AuxKlibInitialize must be called first.

> **Note**: You'll need to add aux_klib.lib as an additional dependency to the driver project.  **Properties > Linker > Input**.



```
NTSTATUS status = AuxKlibInitialize();

if (!NT_SUCCESS(status))
{
	KdPrint(("[!] AuxKlibInitialize failed (0x%08X)", status));
	return;
}
```



We then need to run AuxKlibQueryModuleInformation twice - the first time to get the buffer size required to hold the requested information, and the second time to write that information.

```
ULONG szBuffer = 0;

// run once to get required buffer size
status = AuxKlibQueryModuleInformation(
	&szBuffer,
	sizeof(AUX_MODULE_EXTENDED_INFO),
	NULL);

if (!NT_SUCCESS(status))
{
	KdPrint(("[!] AuxKlibQueryModuleInformation failed (0x%08X)", status));
	return;
}
```



If the call was successful, szBuffer will now hold a value (other than 0 of course).  We can then allocate a pool of memory of the correct size, zero it, and call AuxKlibQueryModuleInformation again.

```
// allocate memory
AUX_MODULE_EXTENDED_INFO* modules = (AUX_MODULE_EXTENDED_INFO*) ExAllocatePoolWithTag(
	PagedPool,
	szBuffer,
	RED_OCTOBER_TAG);

if (modules == nullptr)
{
	status = STATUS_INSUFFICIENT_RESOURCES;
	return;
}

RtlZeroMemory(modules, szBuffer);

// run again to get the info
status = AuxKlibQueryModuleInformation(
	&szBuffer,
	sizeof(AUX_MODULE_EXTENDED_INFO),
	modules);

if (!NT_SUCCESS(status))
{
	KdPrint(("[!] AuxKlibQueryModuleInformation failed (0x%08X)", status));
	ExFreePoolWithTag(modules, RED_OCTOBER_TAG);
	return;
}
```



We can calculate the number of modules that were returned and then iterate over them.

```
// iterate over each module
ULONG numberOfModules = szBuffer / sizeof(AUX_MODULE_EXTENDED_INFO);

for (ULONG i = 0; i < numberOfModules; i++)
{
	// do something
}

ExFreePoolWithTag(modules, RED_OCTOBER_TAG);
return;
```



We can access an individual module using the **i** index, like `AUX_MODULE_EXTENDED_INFO moduleInfo = modules[i];`.  The struct for AUX_MODULE_EXTENDED_INFO is as follows:

```
typedef struct _AUX_MODULE_BASIC_INFO {
    PVOID ImageBase;
} AUX_MODULE_BASIC_INFO, *PAUX_MODULE_BASIC_INFO;

typedef struct _AUX_MODULE_EXTENDED_INFO {
    AUX_MODULE_BASIC_INFO BasicInfo;
    ULONG ImageSize;
    USHORT FileNameOffset;
    UCHAR FullPathName [AUX_KLIB_MODULE_PATH_LEN];
} AUX_MODULE_EXTENDED_INFO, *PAUX_MODULE_EXTENDED_INFO;
```



I'm sure you can spot the information we need.  We have the **ImageBase** and **ImageSize**.  Based on these two, we can calculate the end address of the module.

```
ULONG64 startAddress = (ULONG64)modules[i].BasicInfo.ImageBase;
ULONG imageSize = modules[i].ImageSize;
ULONG64 endAddress = (ULONG64)(startAddress + imageSize);
```



We can then determine if a "RawPointer" lies between those two addresses.

```
if (RawPointer > startAddress && RawPointer < endAddress)
{
	// we found it
}
```