Since version 10 1607, Windows will not load a kernel-mode driver unless it's signed via the Microsoft Dev Portal.  For developers, this first means obtaining an extended validation (EV) code signing certificate from a provider such as DigiCert, GlobalSign, and others.  They must then apply to join the Windows Hardware Dev Center program by submitting their EV cert and going through a further vetting process.  Assuming they get accepted, a driver needs to be signed by the developer with their EV cert and uploaded to the Dev Portal to be approved and signed by Microsoft.

This fairly rigorous process is to protect Windows from malicious and/or unstable code running in the kernel.

This protection can of course be disabled by turning on test signing mode, as we've done with our test VM.  The actual configuration is stored in the boot options and protected with secure boot.  When Windows starts, it will read the boot configuration and set a flag in kernel-memory which is checked on future driver-load events.

The memory region in question is called **g_CiOptions**, which we can see easily in the debugger:

```
kd> dw CI!g_CiOptions L1
fffff804`32b2ad18  000e
```



The default value for these CiOptions is `4|2`.  That's a literal 4 OR 2, which is **6** in hex.  If `DISABLE_INTEGRITY_CHECKS` has been set, CiOptions becomes **0**.  If `TESTSIGNING` is enabled, the default CiOptions are OR'd with 8.  4|2|8 is **E** in hex.

This single bit controls DSE at runtime.  The other bits control different aspects of the code integrity policy, such as debug flags.  If we can change this memory bit from 6 to E, we can effectively bypass DSE and load an unsigned driver.  However, this does represent a bit of a chicken and egg.  Since only existing kernel modules can modify this memory, requiring a driver to disable DSE to load another driver seems like a non-starter.

The most viable way to achieve this is with a legitimately signed driver that has a known vulnerability, such as a write-what-where.