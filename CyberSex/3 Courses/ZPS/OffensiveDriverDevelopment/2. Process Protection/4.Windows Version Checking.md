We've currently hardcoded our offset in-line with our code:  `PROCESS_PROTECTION_INFO* psProtection = (PROCESS_PROTECTION_INFO*)(((ULONG_PTR)eProcess) + 0x6c8);`

If this was run on a different version of Windows, it may very well crash.  We also don't want to update and recompile the driver for each target.  A better approach would be to store known offsets in some sort of lookup for each Windows version.  We could then use [RtlGetVersion](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-rtlgetversion) at runtime to get the current Windows version and pull the correct offset from the lookup.

Start by creating an enum of different Windows versions that you want to support in your driver.  For example, the following contains Windows 10 [versions](https://en.wikipedia.org/wiki/Windows_10_version_history).  Also, be aware that Windows Server has slightly different build numbers than Windows 10.

```
typedef enum _WINDOWS_VERSION
{
	WINDOWS_UNSUPPORTED,
	WINDOWS_REDSTONE_1,		// 14393,
	WINDOWS_REDSTONE_2,		// 15063,
	WINDOWS_REDSTONE_3,		// 16299,
	WINDOWS_REDSTONE_4,		// 17134,
	WINDOWS_REDSTONE_5,		// 17763
	WINDOWS_19H1, 			// 18362
	WINDOWS_19H2,			// 18363
	WINDOWS_20H1,			// 19041
	WINDOWS_20H2,			// 19042
	WINDOWS_21H1,			// 19043
	WINDOWS_21H2			// 19044
} WINDOWS_VERSION, * PWINDOWS_VERSION;
```



Then create a method that will call RtlGetVersion and return one of these enums based on the output.

```
WINDOWS_VERSION
GetWindowsVersion()
{
	RTL_OSVERSIONINFOW info;
	info.dwOSVersionInfoSize = sizeof(info);

	NTSTATUS status = RtlGetVersion(&info);

	if (!NT_SUCCESS(status))
	{
		DbgPrint("[!] RtlGetVersion failed (0x%08X)\n", status);
		return WINDOWS_UNSUPPORTED;
	}

	DbgPrint("[+] Windows Version %d.%d\n", info.dwMajorVersion, info.dwBuildNumber);

	if (info.dwMajorVersion != 10)
	{
		return WINDOWS_UNSUPPORTED;
	}

	switch (info.dwBuildNumber)
	{
	case 17763:
		return WINDOWS_REDSTONE_5;

	default:
		return WINDOWS_UNSUPPORTED;
	}
}
```



In cases where the API call fails or the MajorVersion is not 10, I return **WINDOWS_UNSUPPORTED**.  If it is version 10, then we can switch on the BuildNumber and return one of the known enums.  The version I'm testing on happens to be 17763 ([Redstone 5](https://en.wikipedia.org/wiki/Windows_10_version_1809)).

Next, we can define the lookup.  An array is a possible solution (although not so elegant when only one of the cases is implemented).

```
const ULONG PROCESS_PROTECTION_OFFSET[] =
{
    0x00,   // placeholder
    0x00,   // placeholder
    0x00,   // placeholder
    0x00,   // placeholder
    0x00,   // placeholder
    0x6c8,  // REDSTONE_5
    0x00,   // placeholder
    0x00,   // placeholder
    0x00,   // placeholder
    0x00,   // placeholder
    0x00    // placeholder
};
```



The idea here is that WINDOWS_REDSTONE_5 is index **5** in the WINDOWS_VERSION enum.  So we retrieve index 5 from the PROCESS_PROTECTION_OFFSET array to get the known offset for that version.  To utilise this, we could do:

```
case RED_OCTOBER_DEVICE_PROTECT_PROCESS:
{
	WINDOWS_VERSION windowsVersion = GetWindowsVersion();

	if (windowsVersion == WINDOWS_UNSUPPORTED)
	{
		status = STATUS_NOT_SUPPORTED;
		DbgPrint("[!] Windows Version Unsupported\n");
		break;
	}

	...

	PROCESS_PROTECTION_INFO* psProtection = (PROCESS_PROTECTION_INFO*)(((ULONG_PTR)eProcess) + PROCESS_PROTECTION_OFFSET[windowsVersion]);
```