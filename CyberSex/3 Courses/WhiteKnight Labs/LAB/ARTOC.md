

## ARTOC Notes (See krxa... PDF for course guide)
* **Web Traffic** (HTTPS, HTTP bad!) --> **Relay** (preliminary stuff to a degree) --> **Redirector** (redirect traffic if it is not an operator or a beacon reporting back) --> **C2** (access C2 storage and whatnot.)
* NameCheap for domains is nice but Cloudflare will provide more security afaik.
* ## C2 Components and Notes:
	* **Team Server**: Heart of a C2. Allows malleable profiles to be configured and used, listening for implant callbacks, and operators to collaborate on a given project. C2 client connects to the team server to manage implants, issue commands, and generate new listeners.
	* **Client**: A GUI interface which allows one or more operators to connect to a server and handle the different listeners which can create, generate implants and interact with compromised hosts, and more (Cobalt Strike/Havoc). By default, the client will connect to the team server using its default port 50050 or 40056 for Cobalt Strike and Havoc respectively. 
	* **Beacon/Demon**: Beacons/demons are Cobalt Strike and Havoc’s names for an implant. An implant is the malware agent generated by the C2 to perform post-exploitation tasks. It utilizes listeners for its communication – HTTP and DNS for external communication and SMB and TCP for internal communication. 
	* **Listener**: Protocol specific connection management interfaces which specify what a beacon’s main method of talking to the team server/other implants will be, what sort of traffic will be generated from the listener (team server) to the implant, and in general, how the implant behaves within an environment. 
	* **Loader**: A loader is simply a program which wraps around the implant shellcode. For Cobalt Strike, this loader is generated as part of the Cobalt Strike server through the User-Defined Reflective Loader (UDRL) kit. In Havoc, this is performed via a plugin . The alternative is a custom program developed by the malware developer/red team operator. 
		* The loader can be programmed using any language which interfaces with the Windows API and often contains evasive properties such as patching the Anti-Malware Scan Interface (AMSI) or the Event Tracing for Windows (ETW) functions, or logs system actions being performed respectively. See course guide for more info on loader examples.
* `terraform output` Gets all outputted creds and Apache Guac. frontend
* `terraform fmt`Apply updated configs to terraform lab
* `terraform destroy --auto-approve` Destroy lab; teardown
* `terraform apply "ARTO_CLIENT_MACHINES.tfplan` Build lab with given .tfplan file
* ==Beacon jitter introduces randomness== into when the beacon willcommunicate with the C2; makes it more unpredicatable and 'seemless' or undetectable rather than if it were constantly calling back.
	* ==Beacon sleep time== manages when it will call back to the server, as a default value. The jitter will then be applied to said sleep value to introduce the randomness.
* ==Don't enable staged payloads== for team server since it callback then people can get the payload and analyze it and then its ggs. Stageless will do all the work for us including the beacon data so it can work on its own.
* Team server protection:
	- Allow inbound from specific IPs, ngfw
	- Close as many ports as possible
	- No internet access
* C2 profiles specify how your team server and beacon interact with each other, no internet, emulate google drive, teams, etc. Basically more evasion.
* Spawn/SpawnAs feature is insane for cred dump and whatnot; once a beacon is active on a system you can do a lot of stuff (dump cred, golden ticket, priv esc, etc.)
	* Spawn As will spawn a beacon using dumped creds to basically authenticate itself.
	* Spawn will just spawn a beacon on the system lol.
	* SpawnTo will inject the beacon into a running process. This can work nicely if done right. Be careful since someone seeing notepad connecting to the internet is made sus lo.
		* Sysnative = 32_bit process
		* Syswow64 = 64_bit process
	* `Killdate` is an incredibly important field for your HTTP(S) listener, without it you will basically permanently have a backdoor on a system after a red team operation unless the user kills the beacon themselves.
* A **BOF** or Beacon Object File is an extension of the post-exploitation process(es) for a beacon. Written in C and unlinked since running an .exe will get sniped lol. Object files (.o type) contain functions in binary form but are not executable on their one; they need the injected process of the beacon to do it for them!
* **Relay** uses a CDN sometimes like Azure FrontDoor, AWS Lambda or cloudfront/MS devtunnels; not related to our domain (literal web domain). Relay will not check domain age since anything younger than 90 days will get blocked/warn the user; relay will block that behaviour and let everything run interrupted.
* **Redirectors** will redirect traffic to the C2. Takes traffic and passes it thru a proxy to an internal subnet (10.0.0.x) where all our traffic is supposed to go provided it passes through some rule checks IF there are any.


