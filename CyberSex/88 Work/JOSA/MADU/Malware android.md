  - Android OS Learning Path
    - Module 1: Android platform stack overview (kernel, HAL, ART, framework, apps)
      - Submodule: Linux kernel customizations for Android (wakelocks, binder driver, ashmem/ION memory allocators)
      - Submodule: Hardware Abstraction Layer (HIDL/AIDL evolution) and vendor partition separation
      - Submodule: ART runtime, zygote startup, dexopt/odex/oat flow, JIT vs AOT compilation
      - Submodule: System services map (ActivityManagerService, PackageManagerService, WindowManager, SurfaceFlinger) and boot sequence
    - Module 2: App components, intents, and manifests
      - Submodule: Activity/Service/Receiver/Provider lifecycles; task and back stack behavior
      - Submodule: Intent resolution (explicit vs implicit), intent filters, categories, permissions on intents
      - Submodule: Manifest structure, applicationId vs package name, exported components, process/uid assignment
    - Module 3: Build and debug toolchain (Android Studio, adb, logcat, apktool)
      - Submodule: Gradle build phases, variant/flavor configs, signing configs (debug vs release)
      - Submodule: adb essentials (shell, push/pull, tcpip, port-forward, reverse) and logcat filtering (tags/levels)
      - Submodule: apktool/jadx basics for resource and smali inspection; bundletool for AAB -> APK splits
      - Submodule: Emulator/AVD setup, hardware profiles, Google APIs vs AOSP images
    - Module 4: APK structure, signing, and installation lifecycle
      - Submodule: APK file layout (AndroidManifest.xml, classes.dex, res/, lib/ABI splits, META-INF, resources.arsc)
      - Submodule: v1/v2/v3/v4 signing schemes; signature verification path in PackageManagerService
      - Submodule: Package install flow (PackageInstaller session, staged installs, rollback data)
      - Submodule: App bundle delivery (split APKs, dynamic feature modules, Play Integrity handshake overview)
    - Module 5: Permissions, sandboxing, and data storage basics
      - Submodule: Linux uid/gid per app, SELinux domains, seccomp basics
      - Submodule: Runtime permissions vs install-time; permission protection levels (normal, dangerous, signature, privileged)
      - Submodule: Storage models (internal, external, SAF, scoped storage) and media access changes (API 29+)
      - Submodule: Keystore/Keymaster, BiometricPrompt basics, credential storage patterns
    - Module 6: Networking, WebView, and Binder/IPC fundamentals
      - Submodule: Binder IPC primitives (parcels, transact codes, AIDL), death recipients, service discovery
      - Submodule: Common network stacks (HttpUrlConnection, OkHttp), TLS pinning basics, Network Security Config
      - Submodule: WebView architecture, multiprocess mode, JavaScriptInterface security, Safe Browsing toggles
      - Submodule: Broadcasts (ordered, sticky, runtime restrictions), JobScheduler/WorkManager interplay
    - Module 7: UI lifecycle and resource system (layouts, themes, resources)
      - Submodule: View rendering pipeline (measure/layout/draw), SurfaceFlinger and HWUI/Skia
      - Submodule: Resource qualifiers, configuration changes, density buckets, night mode theming
      - Submodule: Jetpack Compose vs View system overview; navigation patterns and back handling (predictive back)
      - Submodule: Accessibility services and input methods; localization pitfalls
    - Module 8: Performance and battery basics (profilers, Doze, schedulers)
      - Submodule: Profilers (CPU, memory, network, energy) and systrace/perfetto traces
      - Submodule: Doze/App Standby buckets, foreground service limits, alarm batching
      - Submodule: Threading models (Handler/Looper, coroutines, Rx) and ANR diagnostics
      - Submodule: Rendering jank sources, GPU overdraw analysis, layout inspection
    - Module 9: Secure coding baseline (R8/ProGuard, integrity checks overview)
      - Submodule: Shrinking/obfuscation rules, keep rules for reflection/serialization
      - Submodule: Basic tamper checks (signing cert hash, package name, debugger detection) and Play Integrity attestation concepts
      - Submodule: Data protection patterns (encrypted SharedPreferences/SQLCipher, clipboard/notification hygiene)
      - Submodule: Supply-chain basics (third-party SDK vetting, SBOM awareness)
    - Module 10: Mini capstone - build, instrument, and document a small app
      - Submodule: Design a simple client-server feature; implement components and permissions
      - Submodule: Add logging hooks and feature flags; produce build variants (dev/prod) with different configs
      - Submodule: Instrument with profilers and basic security checks; generate a short technical writeup and reproducible build steps

  - Android OS Reverse Engineering Path
    - Module 1: Introduction to Android reverse engineering fundamentals and objectives
      - Submodule: Legal/ethical boundaries; lab-only policy; threat models (research vs red-team vs malware analysis)
      - Submodule: APK anatomy refresh and Dalvik/ART bytecode primer
    - Module 2: Overview of common obfuscation techniques and their purpose
      - Submodule: Identifier renaming, resource obfuscation, string encryption, reflection/indirection
      - Submodule: Control-flow flattening and opaque predicates; junk code insertion
    - Module 3: Static obfuscation methods and challenges in analysis
      - Submodule: Analyzing with jadx/apktool/smali; deobfuscation helpers (simplify, deoptfuscator)
      - Submodule: Resources/manifest tricks (split permissions, dynamic receivers, zero-permission loaders)
    - Module 4: Understanding packing techniques and their detection
      - Submodule: Common packers/loaders; stub vs payload separation; memory unpacking indicators
      - Submodule: Detecting on-disk vs in-memory DEX loading (DexClassLoader, InMemoryDexClassLoader)
    - Module 5: Native code obfuscation and reverse engineering strategies
      - Submodule: JNI bridges, string/cipher routines in native libs, inline assembly patterns
      - Submodule: Tools: Ghidra, IDA Free, Radare2/Cutter, Frida jnitrace; symbol recovery and signature matching
    - Module 6: Runtime-based obfuscation: dynamic techniques and countermeasures
      - Submodule: Anti-debug (ptrace checks, tracerpid), anti-hook (inline/hwbp checks), anti-emulator/anti-root heuristics
      - Submodule: Dynamic code loading, reflection loops, hidden APIs; timing/sleep bombs
    - Module 7: Defensive motivations behind obfuscation in app security
      - Submodule: IP protection, cheat/automation prevention, anti-tamper/integrity checks
      - Submodule: Trade-offs: performance, debuggability, false positives
    - Module 8: Offensive uses of obfuscation, including malware evasion and tampering
      - Submodule: Malware case studies (droppers, bankers, spyware) focusing on evasion layers
      - Submodule: Tampering workflows (repack/sign, resource swap, ad fraud injections)
    - Module 9: Fundamental concepts of reverse engineering including toolchains and workflows
      - Submodule: Standard pipeline: static triage -> dynamic instrumentation -> patch/repack/sign -> verify
      - Submodule: Environment prep: emulator vs physical device, Magisk modules, Frida server setup
      - Submodule: Diffing updates (dexdiff, bindiff) and provenance tracking
    - Module 10: Lab policies emphasizing no external services, local environment setups, and ethical guidelines
      - Submodule: Offline datasets, air-gapped VMs, logging hygiene, chain-of-custody notes
      - Submodule: Safe handling of samples; restoring clean snapshots
    - Module 11: Hands-on labs exploring real-world obfuscation samples and unpacking exercises
      - Submodule: Lab A: Identify and decrypt runtime strings from an obfuscated loader
      - Submodule: Lab B: Unpack a packed APK, dump memory DEX, repackage
      - Submodule: Lab C: Patch a simple root/emulator check and document bypass
    - Module 12: Advanced native code analysis and debugging labs
      - Submodule: Set breakpoints on JNI exports; trace crypto routines; recover keys in memory
      - Submodule: Hook syscalls to monitor file/network behavior; ELF relocation and PLT/GOT inspection
    - Module 13: Techniques for detecting and bypassing runtime obfuscation
      - Submodule: Detecting self-modifying code, decoder loops, and in-memory class loading
      - Submodule: Bypassing anti-instrumentation (ptrace detach, HW breakpoints, API-level hooks)
    - Module 14: Summary of course philosophy and best practices reiterated for emphasis
      - Submodule: Document reproducible scripts; minimal-scope hooks; diff-before/after policy
      - Submodule: Checklist for new samples (hashing, triage, environment notes) and continuous learning resources
