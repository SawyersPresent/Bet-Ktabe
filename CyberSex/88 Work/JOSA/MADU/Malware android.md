

  - Module 1: Introduction to Android reverse engineering fundamentals and objectives
  - Module 2: Overview of common obfuscation techniques and their purpose
  - Module 3: Static obfuscation methods and challenges in analysis
  - Module 4: Understanding packing techniques and their detection
  - Module 5: Native code obfuscation and reverse engineering strategies
  - Module 6: Runtime-based obfuscation: dynamic techniques and countermeasures
  - Module 7: Defensive motivations behind obfuscation in app security
  - Module 8: Offensive uses of obfuscation, including malware evasion and tampering
  - Module 9: Fundamental concepts of reverse engineering including toolchains and workflows
  - Module 10: Lab policies emphasizing no external services, local environment setups, and ethical guidelines
  - Module 11: Hands-on labs exploring real-world obfuscation samples and unpacking exercises
  - Module 12: Advanced native code analysis and debugging labs
  - Module 13: Techniques for detecting and bypassing runtime obfuscation
  - Module 14: Summary of course philosophy and best practices reiterated for emphasis







- Course ethos: hands-on only; never delegate labs to online “upload APK/get report” tools; students keep full local
    control to break/fix their own setups.
  - Why reverse engineer Android: goals, legal/ethical boundaries, required mindset.
  - Lab ground rules (repeated): no blind reliance on automated sandboxes; external tools only after you understand the
    internals they automate.
  - Tooling baseline: APKTool, JADX/Bytecode viewers, Frida, objection, adb + emulator snapshots; setting up repeatable
    lab VMs/emulators.
  - Android app internals refresher: APK structure, manifest, Dex/odex/vdex, resources, signing, app startup flow.
  - Obfuscation fundamentals: what obfuscation is, defensive vs offensive motivations, and how it changes analyst
    workflow.
  - Static obfuscation detection: identifier renaming patterns, junk code, string/class encryption, arithmetic string
    hiding; triage steps in smali/DEX.
  - Dynamic packing: packer indicators, manifest–class list mismatches, DexClassLoader/PathClassLoader use, reflective
    entrypoints, unpack-at-runtime strategies.
  - Native code obstacles: JNI bridge basics, ARM vs x86 implications, emulator evasion by ABI pruning, intro to native
    disassembly.
  - Runtime self-mutation: code item and mmap pointer tampering, post-load object patching, brittleness across Android
    API levels; observation via dynamic tracing.
  - Analyst playbooks: choosing static vs dynamic first, when to shift to emulation with snapshots, safe instrumentation
    patterns.
  - Counter-obfuscation techniques: deobfuscation heuristics, string/unpack script stubs, patching loaders, symbol
    recovery, diffing before/after runtime.
  - Threat-specific labs: defensive obfuscation case study (legit app), offensive obfuscation case study (malware
    sample) with guided hints, no automated reports.
  - Assessment model: lab reports focus on “how it works” explanations, not tool screenshots; reproducibility and
    failure analysis valued.
  - Closing reminder: malware RE is about understanding mechanisms, not button-clicking; keep experiments local, expect
    to break emulators and recover via snapshots.


