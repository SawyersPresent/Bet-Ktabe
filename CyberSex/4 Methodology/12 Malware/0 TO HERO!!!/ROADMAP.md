# Malware Development: Complete Concepts Guide

---

## **PHASE 1: Programming Fundamentals (C Language)**

### **Week 1-2: C Basics**

**Concepts to Learn:**

1. **Variables and data types**
   - `int`, `char`, `float`, `double`
   - `unsigned` vs `signed`
   - Size of types: `sizeof()`

2. **Pointers (CRITICAL - spend extra time here)**
   - What is a pointer? (memory address)
   - `*` (dereference) vs `&` (address-of)
   - Pointer arithmetic
   - NULL pointers

3. **Arrays and strings**
   - Array notation vs pointer notation
   - Character arrays (strings in C)
   - String manipulation

4. **Functions**
   - Function declaration vs definition
   - Parameters vs arguments
   - Return values
   - Pass by value vs pass by reference (using pointers)

**Why this matters for maldev:**
- Pointers are fundamental to memory manipulation
- Understanding memory addresses is critical for injection
- C is the language of Windows API

---

### **Week 3-4: Advanced C Concepts**

**Concepts to Learn:**

1. **Structures (`struct`)**
   - Defining structures
   - Accessing members (`.` vs `->`)
   - Pointers to structures
   - Nested structures

2. **Memory allocation**
   - Stack vs Heap (conceptual understanding)
   - `malloc()`, `calloc()`, `realloc()`, `free()`
   - Memory leaks

3. **Function pointers**
   - Declaration syntax
   - Calling through function pointers
   - Why they matter (callbacks, dynamic function calls)

4. **Typecasting**
   - Implicit vs explicit casting
   - Pointer casting (e.g., `(char*)` to `(int*)`)

5. **Preprocessor directives**
   - `#include`, `#define`, `#ifdef`
   - Macros

**Why this matters for maldev:**
- Structures = Understanding Windows types like `PROCESS_INFORMATION`, `STARTUPINFO`
- Function pointers = Understanding APIs, callbacks, and resolving functions dynamically
- Memory allocation = Manual memory management for injection

---

## **PHASE 2: Windows API Fundamentals**

### **Week 5-6: Basic Windows Programming**

**Concepts to Learn:**

1. **Windows data types**
   - `DWORD`, `HANDLE`, `LPVOID`, `BOOL`, `HMODULE`
   - Why Windows uses these instead of standard C types
   - Hungarian notation (understanding older code)

2. **Handles**
   - What is a handle? (opaque reference to an OS object)
   - Handle types: process handles, thread handles, file handles
   - Closing handles: `CloseHandle()`

3. **Basic Windows APIs**
   - `CreateFile()` - file operations
   - `WriteFile()`, `ReadFile()`
   - `GetLastError()` - error handling in Windows

4. **Error handling**
   - Windows error codes
   - `GetLastError()` and `FormatMessage()`

---

### **Week 7-8: Process and Thread APIs**

**Concepts to Learn:**

1. **Process creation**
   - `CreateProcess()` and its parameters
   - `PROCESS_INFORMATION` structure
   - `STARTUPINFO` structure
   - Process IDs (PIDs)

2. **Process handle operations**
   - `OpenProcess()` - getting handle to existing process
   - Access rights: `PROCESS_ALL_ACCESS`, `PROCESS_VM_READ`, etc.
   - `GetCurrentProcess()`, `GetCurrentProcessId()`

3. **Thread basics**
   - `CreateThread()` vs `CreateRemoteThread()`
   - Thread IDs (TIDs)
   - `WaitForSingleObject()` - synchronization

4. **Process enumeration**
   - `CreateToolhelp32Snapshot()`
   - `Process32First()`, `Process32Next()`
   - Finding processes by name

---

## **PHASE 3: Memory Management Deep Dive**

### **Week 9-10: Virtual Memory Operations**

**Concepts to Learn:**

1. **Memory allocation APIs**
   - `VirtualAlloc()` - allocate memory in current process
   - `VirtualAllocEx()` - allocate in remote process
   - Allocation types: `MEM_COMMIT`, `MEM_RESERVE`, `MEM_RELEASE`
   - Memory protection: `PAGE_EXECUTE_READWRITE`, `PAGE_READWRITE`, etc.

2. **Memory protection**
   - `VirtualProtect()` - change protection in current process
   - `VirtualProtectEx()` - change protection in remote process
   - Why you need to change protections (DEP bypass)

3. **Reading/writing memory**
   - `ReadProcessMemory()` - read from remote process
   - `WriteProcessMemory()` - write to remote process
   - Why you need `PROCESS_VM_READ` / `PROCESS_VM_WRITE` rights

4. **Memory regions and states**
   - Private vs Mapped vs Image memory
   - Committed vs Reserved memory
   - Using `VirtualQueryEx()` to inspect memory

**Key Understanding:**
- **Private Commit Memory**: Allocated with VirtualAlloc, not backed by file on disk
- **Mapped Commit Memory**: Backed by a file on disk (legitimate DLLs)
- **Image Memory**: PE files loaded into memory
- Why this matters: EDR/AV detects execution from unbacked (private) memory

---

### **Week 11-12: PE Format Understanding**

**Concepts to Learn:**

1. **PE structure basics**
   - DOS header (`IMAGE_DOS_HEADER`)
   - NT headers (`IMAGE_NT_HEADERS`)
   - Optional header (`IMAGE_OPTIONAL_HEADER`)
   - Section headers (`IMAGE_SECTION_HEADER`)

2. **Important PE components**
   - Entry point (`AddressOfEntryPoint`)
   - Image base (`ImageBase`)
   - Section characteristics (executable, writable, etc.)
   - `.text`, `.data`, `.rdata` sections

3. **Import/Export tables**
   - Import Address Table (IAT)
   - Import Directory
   - Export Address Table (EAT)
   - How DLLs are loaded and functions resolved

4. **Parsing PE files**
   - Reading PE from disk
   - Walking sections
   - Finding imports
   - Finding exports

**Why PE Parsing is Critical:**
- **Reflective DLL Injection**: Must manually parse and load DLL without LoadLibrary
- **Module Stomping**: Need to find .text section size
- **Process Hollowing**: Must parse both target and malicious PE
- **Import Hooking**: Must locate and modify IAT
- **API Hashing**: Must parse EAT to resolve functions
- **Call Stack Validation**: Must verify return addresses are in valid PE regions

---

## **PHASE 4: Assembly & Low-Level Concepts**

### **Week 13-14: x86/x64 Assembly Basics**

**Concepts to Learn:**

1. **Registers**
   - General purpose: RAX, RBX, RCX, RDX, RSI, RDI
   - Special purpose: RSP (stack pointer), RBP (base pointer), RIP (instruction pointer)
   - Register sizes: RAX (64-bit), EAX (32-bit), AX (16-bit), AL (8-bit)

2. **Common instructions**
   - `MOV` - move data
   - `PUSH` / `POP` - stack operations
   - `CALL` / `RET` - function calls
   - `JMP` / `JE` / `JNE` - jumps (conditional and unconditional)
   - `ADD` / `SUB` / `XOR` / `AND` / `OR` - arithmetic/logic
   - `LEA` - load effective address

3. **Stack operations**
   - Stack grows downward (high to low addresses)
   - `PUSH` decrements RSP, then writes
   - `POP` reads, then increments RSP
   - Stack alignment (16-byte on x64)

4. **Function calling conventions**
   - **x64 Windows (fastcall)**:
     - First 4 args: RCX, RDX, R8, R9
     - Additional args on stack
     - Caller must allocate 32 bytes shadow space
   - **x86 (stdcall/cdecl)**:
     - All args on stack
     - Return value in EAX

5. **Function prologue/epilogue**
   - Saving base pointer
   - Setting up stack frame
   - Allocating local variables
   - Cleaning up and returning

**Why this matters:**
- Understanding how function calls work at machine level
- Critical for shellcode development
- Necessary for understanding call stack manipulation

---

### **Week 15-16: Call Stack Deep Dive**

**Concepts to Learn:**

1. **Stack frames**
   - What is a stack frame?
   - RBP points to current frame base
   - Local variables at [rbp-offset]
   - Parameters at [rbp+offset] (x86) or in registers (x64)

2. **Return addresses**
   - Where they're stored (pushed by CALL instruction)
   - Why they matter (they tell us who called this function)
   - How RET uses them

3. **Call stack walking**
   - Following RBP chain
   - Reading return addresses
   - Understanding stack unwinding

4. **Stack layout (x64 Windows)**
```
High addresses
+------------------+
| Parameter 4      | [rbp+0x28]
| Parameter 3      | [rbp+0x20]  (shadow space)
| Parameter 2      | [rbp+0x18]  (shadow space)
| Parameter 1      | [rbp+0x10]  (shadow space)
+------------------+
| Return Address   | [rbp+0x8]   ← CALL pushed this
+------------------+
| Saved RBP        | [rbp]       ← Current RBP points here
+------------------+
| Local var 1      | [rbp-0x8]
| Local var 2      | [rbp-0x10]
| ...              |
+------------------+ ← RSP
Low addresses
```

5. **Why call stack matters for maldev**
   - EDR/AV walks call stack to check return addresses
   - Return addresses in unbacked memory = suspicious
   - Call stack spoofing manipulates these return addresses
   - Understanding this is critical for evasion

**Key Concept:**
When you call `MessageBoxA` from injected code:
- Return address on stack points to your unbacked memory
- EDR sees this and flags it as suspicious
- Solution: Call stack spoofing makes it look legitimate

---

## **PHASE 5: DLL Injection Techniques**

### **Week 17-18: Classic Injection**

**Concepts to Learn:**

1. **DLL Injection via CreateRemoteThread**
   - Allocate memory in target with `VirtualAllocEx`
   - Write DLL path using `WriteProcessMemory`
   - Get address of `LoadLibraryA`
   - Create remote thread pointing to `LoadLibraryA`
   - Why this works: LoadLibrary loads DLL into target process

2. **GetProcAddress and LoadLibrary**
   - How to dynamically resolve functions
   - Why this matters (avoiding import table)
   - Runtime API resolution

3. **Thread contexts**
   - `GetThreadContext()` / `SetThreadContext()`
   - Thread hijacking technique
   - Redirecting thread execution

**Detection vectors:**
- CreateRemoteThread is heavily monitored
- Writing to remote process memory is suspicious
- Requires high privileges

---

### **Week 19-20: Shellcode Basics**

**Concepts to Learn:**

1. **What is shellcode?**
   - Position-independent code (PIC)
   - Self-contained executable bytecode
   - No fixed addresses
   - No external dependencies

2. **Writing simple shellcode**
   - Using assembly
   - Avoiding null bytes (for string-based exploits)
   - Resolving API addresses at runtime
   - PEB walking to find kernel32.dll

3. **Shellcode execution**
   - Allocating executable memory
   - Copying shellcode
   - Jumping to shellcode
   - Function pointer casting

4. **Shellcode generation tools**
   - msfvenom
   - Custom shellcode generators
   - Encoding and obfuscation

---

### **Week 21-22: Advanced Injection (Reflective DLL)**

**Concepts to Learn:**

1. **Reflective loading concept**
   - Manual PE mapping without using LoadLibrary
   - Resolving imports yourself
   - Applying relocations
   - Why: Avoids going through LoadLibrary (monitored API)

2. **Key steps in reflective loading**
   - Parse PE headers from DLL buffer
   - Allocate memory for image
   - Map sections into memory
   - Process relocations (fix addresses)
   - Resolve imports (get API addresses)
   - Set memory protections
   - Call entry point (DllMain)

3. **sRDI (Shellcode Reflective DLL Injection)**
   - Converting DLL to shellcode
   - Bootstrap loader
   - Self-contained DLL loading

4. **Why reflective DLL injection matters**
   - DLL never touches disk
   - Bypasses many EDR/AV detections
   - No LoadLibrary calls
   - Commonly used in modern malware

**Key Understanding:**
- Normal DLL loading: OS does everything (LoadLibrary)
- Reflective loading: You implement the loader yourself
- Result: DLL loaded in memory without OS knowledge

---

## **PHASE 6: Evasion Techniques**

### **Week 23-24: Call Stack Spoofing & Module Stomping**

**Concepts to Learn:**

1. **Why call stacks are checked**
   - EDR hooks API functions
   - Walks stack to check caller legitimacy
   - Flags unbacked memory regions
   - Security products validate execution flow

2. **The problem with injected code**
   - Code in private (unbacked) memory
   - Return addresses point to non-module memory
   - EDR can detect this immediately
   - Example: MessageBoxA called from 0x12340000 (no backing file)

3. **Call stack spoofing techniques**
   - ROP gadgets for legitimate return addresses
   - Stack pivoting
   - Synthetic stack frames
   - Making call stack look legitimate

4. **Module stomping/overloading**
   - Finding suitable target DLL (large .text section)
   - Overwriting legitimate DLL code section
   - Executing from "legitimate" module
   - Return addresses now point to real module

5. **Why module stomping works**
   - Memory is still MEM_IMAGE (file-backed)
   - Module appears in process module list
   - Return addresses point to legitimate DLL
   - Much harder to detect

6. **The constraint**
   - Target DLL's .text section must be large enough
   - Cannot use VirtualAllocEx to expand (creates private memory)
   - Must find DLL with sufficient space

**Real-world scenario:**
```
Without evasion:
MessageBoxA ← 0x02A40000 (unbacked memory) ← DETECTED

With module stomping:
MessageBoxA ← 0x7FFE1234567 (in kernel32.dll) ← Looks legitimate

With call stack spoofing:
MessageBoxA ← 0x7FFE9876543 (in user32.dll) ← Synthetic but looks real
```

---

## **PHASE 7: Additional Important Concepts**

### **Operating System Fundamentals**

**Concepts to Learn:**

1. **Virtual memory architecture**
   - Paging and page tables
   - Virtual address translation
   - Physical vs virtual memory
   - Memory mapping

2. **Process address space**
   - User mode vs kernel mode
   - Address space layout
   - Where DLLs, stack, heap are located
   - ASLR (Address Space Layout Randomization)

3. **Process Environment Block (PEB)**
   - Structure of PEB
   - Process information stored in PEB
   - Module list in PEB
   - Using PEB to enumerate loaded modules

4. **Thread Environment Block (TEB)**
   - Per-thread information
   - Stack base and limit
   - Last error value

---

### **Advanced Memory Concepts**

**Concepts to Learn:**

1. **Memory-mapped files**
   - `CreateFileMapping()` and `MapViewOfFile()`
   - Sharing memory between processes
   - Loading PE files with memory mapping

2. **Sections and object manager**
   - Named sections
   - Shared memory
   - Section objects

3. **Working sets and memory pressure**
   - How Windows manages memory
   - Page faults
   - Memory trimming

---

### **Security Mechanisms**

**Concepts to Learn:**

1. **DEP (Data Execution Prevention)**
   - NX bit (No eXecute)
   - Why you need PAGE_EXECUTE_READWRITE
   - ROP to bypass DEP

2. **ASLR (Address Space Layout Randomization)**
   - Randomizing base addresses
   - Information disclosure to leak addresses
   - ASLR bypass techniques

3. **CFG (Control Flow Guard)**
   - Validating indirect calls
   - CFG bitmap
   - Bypass techniques

4. **API hooking detection**
   - Inline hooks
   - IAT hooks
   - SSDT hooks (kernel)
   - Direct syscalls to bypass hooks

---

### **EDR/AV Evasion Concepts**

**Concepts to Learn:**

1. **How EDR/AV works**
   - User-mode hooks
   - Kernel callbacks
   - ETW (Event Tracing for Windows)
   - Behavioral analysis

2. **Detection methods**
   - Signature-based detection
   - Behavioral detection
   - Heuristic analysis
   - Memory scanning
   - Call stack analysis

3. **Evasion techniques**
   - Unhooking APIs
   - Direct syscalls
   - Heaven's Gate (WoW64 transition)
   - Sleep obfuscation
   - Timing attacks

4. **AMSI (Anti-Malware Scan Interface)**
   - What AMSI scans
   - AMSI bypass techniques
   - Patching AmsiScanBuffer

---

### **Debugging and Analysis**

**Concepts to Learn:**

1. **Using debuggers**
   - Setting breakpoints
   - Stepping through code (F7, F8)
   - Examining registers and memory
   - Stack traces

2. **Anti-debugging techniques**
   - IsDebuggerPresent()
   - PEB BeingDebugged flag
   - Timing checks
   - Debugger detection

3. **Reverse engineering**
   - Reading disassembled code
   - Understanding IDA/Ghidra output
   - Identifying functions and structures
   - Pattern recognition

---

### **Practical Malware Techniques**

**Concepts to Learn:**

1. **Process hollowing**
   - Create suspended process
   - Unmap original executable
   - Map malicious executable
   - Resume execution

2. **APC injection**
   - QueueUserAPC()
   - Asynchronous procedure calls
   - Executing code in target thread

3. **Process Doppelgänging**
   - NTFS transactions
   - Atomic file operations
   - Loading from transacted file

4. **Thread execution hijacking**
   - Suspend target thread
   - Modify thread context (RIP)
   - Resume thread with new execution

5. **Atom bombing**
   - Global atom table
   - NtQueueApcThread
   - Code execution via atoms

---

## **Key Principles to Remember**

### **Memory Management**
- Stack: Automatic, LIFO, fixed size, fast
- Heap: Manual, flexible size, slower
- Virtual memory: OS abstraction, paging, protection

### **PE Format**
- Every Windows executable is a PE file
- Understanding PE is mandatory for advanced techniques
- Sections contain different types of data
- Import/Export tables define DLL dependencies

### **Call Stack**
- LIFO structure tracking function calls
- Contains return addresses and local variables
- Critical for EDR detection
- Must understand to implement evasion

### **Injection Methods**
- Classic: CreateRemoteThread (heavily monitored)
- Reflective: Manual PE loading (harder to detect)
- Shellcode: Position-independent code
- Each has trade-offs in stealth vs complexity

### **Evasion**
- Understand what defenders look for
- Call stack must appear legitimate
- Memory regions should be backed by files
- Avoid suspicious API patterns
- Timing and behavior matter

---

## **Timeline Summary**

- **Weeks 1-4**: C Programming Fundamentals
- **Weeks 5-8**: Windows API Basics
- **Weeks 9-12**: Memory Management & PE Format
- **Weeks 13-16**: Assembly & Call Stack
- **Weeks 17-22**: Injection Techniques
- **Weeks 23-24**: Evasion Techniques

**Total Time**: ~6 months of dedicated study

---

## **Study Approach**

1. **Read and understand concepts**
2. **Code exercises to practice**
3. **Debug in x64dbg to SEE it happen**
4. **Experiment and break things**
5. **Document your learning**
6. **Build projects to solidify knowledge**

The key is **hands-on practice** - concepts mean nothing without implementation!