
# Callstack Concept

how does a function know when to wait for another function or to pass its data to another function?. What is a callstack?


definitions:
- Stack frame



- Introduction
	- When you call a function the system sets aside space in memory for that function to do its necessary work.
		- usually these chunks of memory are called **stack frames** or **function frames**
	- More than one function's stack frames may exist in memory at a given time. If main() calls move(), which then calls direction(), 
		- That means multiple functions can have stack frames in memory at the same time
		- Usually a single function invocation has only one stack frame
	- Only one of those frames will ever be active at a given time
- The call stack
	- these frames are arranged in a stack. The frame for the most-recently called function is always on the top of the stack.
	- When a new function is called a new frame is pushed onto the top of the stack and becomes the active frame
	- when a function finishes its work, its frame is popped off of the stack and the frame immediately below it becomes the new active function on the top of the stack. This function picks up immediately where it left off
		- As an example right now in our example we have direction() as the function ontop of the stack thats active, then its move() and then finally main() at the bottom. 
		- They are just passively waiting to become the active frame
		- whatever was the active frame if there is one is on pause and is in a holding pattern waiting to be the active frame again
		- So for example if its a void function with no return value that frame is popped off of the stack 
		- the second frame becomes the new active frame. 


Factorial file to make things easier


```C
int fact(int n)
{
	if (n==1)
		return 1;
	else
		return n * fact(n-1);
}

int main(void)
{
	printf("%i\n", fact(5));
}
```


The call stack right now is `main() -> printf()`, the first thing main does is it calls `printf`. as soon as it does that main is on pause and is just waiting for `printf` to do its work. it doesnt know what its printing or whats happening so right now so it needs to make another function call. so now the stack would look like `main() -> printf() -> fact(5)`. so now `fact(5)` is the active frame!.

Because of how factorials work and how the code is structured the codes going to check is n=1?, if not `return n * fact(n-1);`. so now `fact(5)` is calling a new function passing in another variable which is now `fact(4)`. so now there is a new function called and due to do that the call stack looks like as follows `main() -> printf() -> fact(5) -> fact(4)` and from this pattern we can tell how the process goes. the call stack ends up being

`main() -> printf() -> fact(5) -> fact(4) -> fact(3) -> fact(2) -> fact(1) ` 

So now after this is all said and done, all of them are hanging out and waiting to be the new active frame again. now that the `fact(1)` is returning 1, that frame is done! so that frame is essentially `popped` off. at this point the frame is destroy and `fact(2)` can get unpaused!. So what happens now? when it gets unpaused it'll return 2 x 1 = 2!, now `fact(3)` was waiting for `fact(2)` to return its value and now `fact(3)` can do its calculation which is `3 x 2 = 6`! . so now  with fact(4) you can see the pattern here. `4 x 6 = 24` and itll return that to factorial of 5 and then itll finally be `5 x 24 = 120` now finally everything gets popped off and then it goes back to `printf()`! 



https://youtu.be/aCPkszeKRa4
https://specterops.io/blog/2022/06/27/understanding-the-function-call-stack/


